\subsection{EventConsumerModule}
\label{subsec:eventconsumer-module}

\subsubsection{Mục đích}

\texttt{EventConsumerModule} là một service xử lý nền (background processing service) chạy bên trong ứng dụng NestJS chính. Nó \textbf{không} phải là một ứng dụng worker độc lập. Vai trò duy nhất của nó là làm "người tiêu thụ" (Consumer) trong kiến trúc bất đồng bộ của hệ thống.

Service này liên tục "hỏi thăm" (poll) hàng đợi AWS SQS. Khi có một sự kiện mới, nó sẽ nhận lấy, phân tích và thực thi các logic nghiệp vụ nặng (đặc biệt là các thao tác ghi vào CSDL) một cách bất đồng bộ. Kiến trúc này giúp tách biệt hoàn toàn việc tiếp nhận sự kiện khỏi việc xử lý, đảm bảo các lớp giao tiếp như Gateway luôn có hiệu năng cao và phản hồi nhanh.

\subsubsection{Kiến trúc và Luồng hoạt động}

Không giống như các thư viện consumer tự động, \texttt{EventConsumerService} hiện thực một luồng xử lý thủ công nhưng rất rõ ràng và mạnh mẽ.

\begin{description}
    \item[Khởi động (Bootstrap)] Logic được khởi tạo trong phương thức \texttt{onApplicationBootstrap}, một lifecycle hook của NestJS. Điều này đảm bảo polling chỉ bắt đầu sau khi toàn bộ ứng dụng đã sẵn sàng.
    
    \item[Vòng lặp Polling vô hạn] Phương thức \texttt{startPolling} chứa một vòng lặp \texttt{while(true)}. Bên trong vòng lặp, nó liên tục gửi \texttt{ReceiveMessageCommand} đến SQS. Lệnh này có \texttt{WaitTimeSeconds: 20}, nghĩa là nó sẽ giữ kết nối mở trong 20 giây để chờ tin nhắn (long polling), giúp giảm chi phí và số lượng request.
    
    \item[Xử lý và Xóa tin nhắn] Khi nhận được tin nhắn, service sẽ gọi \texttt{handleMessage}. Nếu \texttt{handleMessage} thực thi thành công, service sẽ ngay lập tức gửi một \texttt{DeleteMessageCommand} đến SQS để xóa tin nhắn khỏi hàng đợi, ngăn chặn việc xử lý lại. Nếu có lỗi xảy ra, tin nhắn sẽ không bị xóa và sẽ được SQS cung cấp lại sau một khoảng thời gian, đảm bảo độ tin cậy.
    
    \item[Giao tiếp ngược qua Redis Pub/Sub] Sau khi xử lý xong một sự kiện và ghi dữ liệu vào CSDL (ví dụ: lưu tin nhắn mới), service này sẽ \textbf{publish} một sự kiện mới vào một kênh Redis Pub/Sub. \texttt{GatewayModule} đang lắng nghe (subscribe) kênh Redis này. Khi nhận được sự kiện, Gateway sẽ biết rằng có một tin nhắn mới cần được gửi real-time đến các client liên quan. Đây là cơ chế giao tiếp ngược, tách biệt giữa bên ghi CSDL và bên phát sự kiện real-time.
\end{description}

\subsubsection{Phân tích các Phương thức Quan trọng}

Toàn bộ logic của module này nằm trong file \texttt{event-consumer.service.ts}.

\begin{itemize}
    \item \texttt{handleMessage(message)}: Đây là một bộ điều phối (dispatcher). Nó nhận tin nhắn thô từ SQS, parse nội dung JSON, sau đó dựa vào thuộc tính \texttt{type} của sự kiện (ví dụ: \texttt{NEW\_MESSAGE\_FROM\_VISITOR}) để gọi đến phương thức xử lý nghiệp vụ nội bộ phù hợp.
    
    \item \texttt{handleNewMessageFromVisitor(payload)}: Phương thức private chứa logic nghiệp vụ cốt lõi khi có một tin nhắn mới từ visitor. Nó thể hiện hai quyết định kiến trúc quan trọng:
    \begin{itemize}
        \item \textbf{Giao tác CSDL (Database Transaction):} Toàn bộ chuỗi các thao tác ghi vào cơ sở dữ liệu -- tìm/tạo visitor, tìm/tạo conversation, tạo message, và cập nhật conversation -- đều được bọc trong một khối \texttt{this.entityManager.transaction}. Điều này đảm bảo tính nguyên tử (atomicity): tất cả các bước hoặc sẽ cùng thành công, hoặc sẽ cùng thất bại và được rollback, ngăn chặn hoàn toàn khả năng dữ liệu bị rơi vào trạng thái không nhất quán.
        \item \textbf{Publish kết quả lên Redis:} Sau khi transaction thành công và tin nhắn đã được lưu, phương thức này sẽ gọi \texttt{this.redisPublisher.publish(...)} để thông báo cho các phần khác của hệ thống (cụ thể là Gateway) về sự kiện này, hoàn tất luồng xử lý bất đồng bộ.
    \end{itemize}
\end{itemize}